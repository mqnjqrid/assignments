newchild$word = substr(newword, 1, current_length)
newchild$weight = newweight
#        print(treenode, "weight", "word")
treenode = newchild
}
# the newword has been placed in the trie and the loop will be  exited
break
}
}
treenode$intheset = TRUE
treenode$objweight = newweight
}
trie = Node$new("")
trie$weight = 0
trie$objweight = 0
trie$intheset = FALSE
filltree(trie, "Scizor", 2000)
print(trie, "weight", "word")
filltree(trie, "Sukataka", 3000)
print(trie, "weight", "word")
filltree(trie, "Scukat", 4000)
print(trie, "weight", "word")
filltree = function(treenode, newword, newweight) {
newword = tolower(newword)
# treenode is the starting node, newword is the word to be inserted into the subtrie of treenode, newweight is the corresponding weight
if (treenode$weight < newweight) {
treenode$weight = newweight
}
for (length_word in 1:stri_length(newword)) {
print(paste("child_", substr(newword, 1, length_word), sep = ''))
matchnode = NULL#treenode$paste("child_", substr(newword, 1, length_word), sep = '')
for (child in treenode$children) {
if (tolower(child$name) == tolower(paste("child_", substr(newword, 1, length_word), sep = ''))) {
matchnode = child
#        cat("matchnode\n")
#        print(matchnode)
#break
}
}
if (!is.null(matchnode)) {
if (treenode$weight < newweight) {
treenode$weight = newweight
}
if (matchnode$weight < newweight) {
matchnode$weight = newweight
}
treenode = matchnode
} else {
# if the sub string of the newword does not exist already, we create a new path for it
for (current_length in (length_word):stri_length(newword)) {
newchild = treenode$AddChild(paste("child_",tolower(substr(newword, 1, current_length)), sep = ""))  # the trie nodes are named "child_word1" if the "word1" is the word they contain
newchild$weight = newweight
#        print(treenode, "weight", "word")
treenode = newchild
}
# the newword has been placed in the trie and the loop will be  exited
break
}
}
treenode$intheset = TRUE
treenode$objweight = newweight
}
trie = Node$new("")
trie$weight = 0
trie$objweight = 0
trie$intheset = FALSE
filltree(trie, "Scizor", 2000)
print(trie, "weight", "word")
filltree(trie, "Sukataka", 3000)
print(trie, "weight", "word")
filltree(trie, "Scukat", 4000)
print(trie, "weight", "word")
create_trie = function(filename) {
#wordset = read.table(paste("C:/Users/manja/36-750/assignments-mqnjqrid/autocomplete-me/", filename, ".txt", sep = ''), # Used to read the text file. Address location might change if running on another PC
#                     sep = '\t', header = FALSE, stringsAsFactors = FALSE, skip = 1, fill = TRUE, quote = "\"")
wordset = read.table(filename, sep = '\t', header = FALSE, stringsAsFactors = FALSE, skip = 1, fill = TRUE, quote = "\"")
colnames(wordset) = c("weight", "word")
wordset$weight = as.numeric(wordset$weight)
trie = Node$new("")
# creating an empty trie
trie$weight = 0
# weight is the maximum of the weights of all the words present in the subtrie of the trie node
trie$objweight = 0
# objweight is the weight of the word at the trie node if that word also belongs to our file 'filename'
trie$intheset = FALSE
# TRUE or FALSE correspond to wether the word at the trie node also belongs to the set or not respectively
for (i in 1:length(wordset$weight)) {
filltree(trie, wordset$word[i], wordset$weight[i])  # resding entries from file 'filename' and entering in trie
}
return(trie)
}
tree_to_queue = function(treenode, queue) { #reads the children of a trie node and transfers them into a priority queue
for (tren in treenode$children) {
queue$push(tren, priority = tren$weight)
}
if (!is.null(treenode$intheset) && (treenode$intheset)) {         # if the trie word is in the file, then we also add the values at the trie node itself into the queue by creating a new node object with no children to avoid double reading
tnode = Node$new(treenode$name)
#    tnode$word = treenode$word
tnode$weight = treenode$objweight
tnode$intheset = TRUE
tnode$objweight = treenode$objweight
queue$push(tnode, priority = tnode$objweight)
}
return(queue)
}
queue_regenerate = function(queue, k) {  # read the contents of a priority queue and then moves to the children of the elements in the queue and restricts length and returns the new queue consisting of the children
queue_nextgen = PriorityQueue$new()    # new empty priority queue to store the new nodes obtained from the children of the current queue nodes and any current queue node that belongs to our data file
for (i in 1:min(queue$size(), k)) {
next_node = queue$poll()
if (!is.null(next_node)) {
queue_nextgen = tree_to_queue(next_node, queue_nextgen)
}
}
numchild = 0
for (i in 1:queue_nextgen$size()) {
numchild = numchild + length((queue_nextgen$peek(i))$children)
}
if (numchild == 0) {
return(queue_nextgen)    # if the elements in the queue_nextgen have no children, we stop and return queue_nextgen
} else {
return(queue_regenerate(queue_nextgen, k))    # else we pass queue_nextgen to function queue_regenerate to process its children and update the queue_nextgen
}
}
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(queuemodify$peek(i)$word, queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
triepok = create_trie("C:/Users/manja/36-750/assignments-mqnjqrid/autocomplete-me/pokemon.txt")
findsuggestion("lan", 5, triepok)
findsuggestion("lan", 5, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
print(queuemodify)
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(queuemodify$peek(i)$word, queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("lan", 5, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
print(queuemodify)
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(queuemodify$peek(i)$word, queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("lan", 5, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
print(queuemodify)
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("lan", 5, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
triepok = create_trie("C:/Users/manja/36-750/assignments-mqnjqrid/autocomplete-me/pokemon.txt")
findsuggestion("lan", 5, triepok)
findsuggestion("l", 5, triepok)
findsuggestion("l", 1, triepok)
findsuggestion("l", 0, triepok)
findsuggestion("l", 2, triepok)
findsuggestion("l", 3, triepok)
findsuggestion("l", 0, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
stopifnot(k > 0 || nchar(xword) > 0)
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("l", 0, triepok)
findsuggestion("l", 1, triepok)
findsuggestion("", 1, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
stopifnot((k > 0) || (nchar(xword) > 0))
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("", 1, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
print(nchar(xword))
print(k)
stopifnot((k > 0) || (nchar(xword) > 0))
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("", 1, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
print(nchar(xword))
print(k)
stopifnot((k > 0) && (nchar(xword) > 0))
queue = PriorityQueue$new()
if (xword == '') {
treenode = trie1
} else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
}
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("", 1, triepok)
findsuggestion("d", 1, triepok)
findsuggestion("d", 0, triepok)
findsuggestion("Pikachu", 4, triepok)
findsuggestion = function(xword, k, trie1) { # xword is the partial or whole word for which suggestions are needed. k is the maximum number of suggestions
stopifnot((k > 0) && (nchar(xword) > 0))
queue = PriorityQueue$new()
#  if (xword == '') {
#    treenode = trie1
#  } else {
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
#  }
if (is.null(treenode)) {
return(NULL)
}
queue = tree_to_queue(treenode, queue)
queuemodify = queue_regenerate(queue, k)
# the queue containing a set of nodes in the trie shifts towards the bottom of the trie passing through the children until it ends up with at most k nodes with maximum priority containing words that belong to the file
suggestion_table = data.table(word = character(), weight = numeric())
# creating an empty table in which we will store the suggested words and their corresponding weights
for (i in 1:queuemodify$size()) {
suggestion_table = rbind(suggestion_table, list(substr(queuemodify$peek(i)$name, 7, nchar(queuemodify$peek(i)$name)), queuemodify$peek(i)$weight))
}
# suggestion_table is the final data table containing the word suggestions and the weights in decreasing order
return(suggestion_table)
}
findsuggestion("Pikachu", 4, triepok)
print(triepok, "weight", "objweight")
k = 5
suggest = rep(list(NA, 0), times = k)
suggest
a = PriorityQueue
a
a = PriorityQueue$new(n)
a = PriorityQueue$new(k)
??PriorityQueue
k = 5
suggest = PriorityQueue$new(data = rep(NA, k), priorities = rep(0, k)) #rep(list(NA, 0), times = k)
suggest = PriorityQueue$new(data = rep(NA, times = k), priorities = rep(0, times = k)) #rep(list(NA, 0), times = k)
suggest = PriorityQueue$new(data = list(rep(NA, times = k)), priorities = rep(0, times = k)) #rep(list(NA, 0), times = k)
suggest
suggest$peek(1)
suggest$peek(2)
?list
suggest = PriorityQueue$new(data = as.list(rep(NA, times = k)), priorities = rep(0, times = k)) #rep(list(NA, 0), times = k)
suggest
suggest$peek(2)
suggest$peek(1)
suggest$peek(5)
suggest$peek(3)
suggest$peek(4)
xx <- lapply(c(3,5,7,2,4), function(i) list(name=LETTERS[i], value=i))
class(xx) <- "myobj"
xx
xx <- lapply(c(3,5,7,2,4), function(i) list(name=LETTERS[i], value=i))
xx
k = 5
suggest = PriorityQueue$new(data = as.list(rep(NA, times = k)), priorities = rep(0, times = k)) #rep(list(NA, 0), times = k)
treenode = FindNode(trie1, paste("child_", tolower(xword), sep = '')) # finds the appropriate node the tree which matches the xword
queue = tree_to_queue(treenode, queue)
treenode = FindNode(triepok, paste("child_", tolower(la), sep = '')) # finds the appropriate node the tree which matches the xword
treenode = FindNode(triepok, paste("child_", tolower("la"), sep = '')) # finds the appropriate node the tree which matches the xword
queue = PriorityQueue$new()
queue = tree_to_queue(treenode, queue)
length(queue$priorities)
k = 5
suggest = PriorityQueue$new(data = as.list(rep(NA, times = k)), priorities = rep(0, times = k)) #rep(list(NA, 0), times = k)
queue_next = PriorityQueue$new()
qelement = queue$poll()
if (max(qelement$weight, qelement$objweight, na.rm = TRUE) > -suggest$peek(k)$priority) {
if (length(queue_next$priorities) < k) {
queue_next$push(qelement)
}
if (qelement$objweight > -suggest$peek(k)$priority) {
suggest$poll()
suggest$push(data = qelement$name, priority = -qelement$objweight)
}
}
queue_next = PriorityQueue$new()
queue
treenode = FindNode(triepok, paste("child_", tolower("la"), sep = '')) # finds the appropriate node the tree which matches the xword
queue = PriorityQueue$new()
queue = tree_to_queue(treenode, queue)
k = 5
suggest = PriorityQueue$new(data = as.list(rep(NA, times = k)), priorities = rep(0, times = k)) #rep(list(NA, 0), times = k)
queue_next = PriorityQueue$new()
qelement = queue$poll()
(max(qelement$weight, qelement$objweight, na.rm = TRUE) > -suggest$peek(k)$priority)
qelement
names(qelement)
qelement$weight
qelement$objweight
max(qelement$weight, qelement$objweight, na.rm = TRUE, null.rm = TRUE) > -suggest$peek(k)$priority)
max(qelement$weight, qelement$objweight, na.rm = TRUE, null.rm = TRUE)
max(qelement$weight, qelement$objweight, na.rm = TRUE, null.rm = TRUE) > 90
suggest$peek(k)$priority
suggest
(suggest$peek(1))$priority
(suggest$peek(1))
(suggest)
(suggest$peek(1))
(suggest$peek(2))
max(suggest$priorities)
if (max(qelement$weight, qelement$objweight, na.rm = TRUE, null.rm = TRUE) > -max(suggest$priorities)) {
if (length(queue_next$priorities) < k) {
queue_next$push(qelement)
}
if (qelement$objweight > -suggest$peek(k)$priority) {
suggest$poll()
suggest$push(data = qelement$name, priority = -qelement$objweight)
}
}
if (max(qelement$weight, qelement$objweight, na.rm = TRUE, null.rm = TRUE) > -max(suggest$priorities)) {
if (length(queue_next$priorities) < k) {
queue_next$push(qelement)
}
if (qelement$objweight > -max(suggest$priorities)) {
suggest$poll()
suggest$push(data = qelement$name, priority = -qelement$objweight)
}
}
qwelement
qelement
if (length(queue_next$priorities) < k) {
queue_next$push(qelement)
}
suggest$push(data = qelement$name, priority = -qelement$objweight)
suggest$push( qelement$name, priority = -qelement$objweight)
suggest$push( qelement$name, priority = 99)#-qelement$objweight)
suggest$push( qelement$name, Priority = 99)#-qelement$objweight)
qelement$name
suggest$push( qelement$name, priority = 99)#-qelement$objweight)
suggest
suggest$push( qelement$name, priority = 99)#-qelement$objweight)
suggest
suggest$poll()
suggest$push(data = qelement$name, priority = -qelement$objweight)
suggest
suggest$push(qelement$name, priority = -qelement$objweight)
suggest
qelement4objweight
qelement$objweight
suggest$push(qelement$name, priority = -99)#qelement$objweight)
suggest
suggest$push(qelement$name, priority = 99)#qelement$objweight)
image1 = matrix(runif(25, 0, 1), nrow = 5, ncol = 5)
threshold = 0.5
image2 = apply(image1, c(1, 2), function(x) { return(x > threshold)})
coordinates = which(image2 == 1, arr.ind = T)
image3 = image2
pixellabel = rep(0, dim(coordinates)[1])
pixellabel[1] = 1
install.packages("igraph")
library(igraph)
install.packages("igraph")
library(igraph)
bfs(make_ring(10) %du% make_ring(10), root=1, "out",
order=TRUE, rank=TRUE, father=TRUE, pred=TRUE,
succ=TRUE, dist=TRUE)
f <- function(graph, data, extra) {
print(data)
FALSE
}
tmp <- bfs(make_ring(10) %du% make_ring(10), root=1, "out",
callback=f)
f <- function(graph, data, extra) {
data['succ'] == -1
}
bfs(make_ring(10) %du% make_ring(10), root=1, callback=f)
?bfs
